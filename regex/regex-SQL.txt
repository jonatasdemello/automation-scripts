**************************************************
Find and Replace Regular Expression Examples SQL
**************************************************

https://www.red-gate.com/simple-talk/databases/sql-server/tools-sql-server/regex-based-finding-and-replacing-of-text-in-ssms/
https://learn.microsoft.com/en-us/sql/ssms/scripting/search-text-with-regular-expressions?redirectedfrom=MSDN&view=sql-server-ver16


To take out blank lines (as when you import code from Firefox sometimes) find

    \n @\n      and replace with    \n

To find all instances of INT that aren't commented out  try (this is an example of a good use for a negative look-behind to check that the line isn’t commented)

    ^~(:b*--).*:bINT>

To select up to the first hundred characters in a line (This will try to select 100 characters from the start of the line, and only if it fails, it will select all of them)

    ^(.^100)|(.*)


To insert a string at a particular column position

    ^{.^100}    And replace with    \1'I've inserted this'

(or whatever!) This simply matches a line with 100 characters  and replaces the first hundred characters with the first hundred characters plus the string you want to insert.

To delete ten columns after column 100 use this

    ^{(.^100)}{.^10}    Replace with    \1

What would happen if you used  \2\1? Yeah. Useful once in a while!

To find either a quoted string or a delimited string, use

("[^"]*")|(\[[^\[]*\])

To replace all quoted strings with quoted delimiters, find

("{[^"]*}")

… and replace with

\[\1\]

This shows how to create a capturing group using {},  and use it in the replace expression. It can also be used in the find expression

To remove inline comments that take the whole line,  find

^:b*--.*$

… and replace with nothing

Here, we are using a greedy quantifier * to find the entire comment  line (line starting with --)

To find any valid object name with delimiters

\[{[A-Za-z_#@][A-Za-z0-9#$@_]*}\]

to take out the quoted delimiters [ and ] where they aren't necessary, replace with

\1

This illustrates the use of character class definitions to determine whether the delimited strings contains only characters that are valid in a SQL identifier.

To find 'tibbling' (use of tbl, vw, fn, or usp prefixes) use this

<(tbl|vw|fn|usp)[A-Za-z0-9#$@_]*>

Here we show one of the most useful of constructs, where alternative strings to search for are listed. It also shows how the special ‘<’and ‘>’ characters are used to delimit the start and end of a word.

to de-tibblize code, us this

<(tbl|vw|fn|usp){[A-Za-z0-9#$@_]*}>

… and replace with …

\1

Here we add a capturing group (Microsoft calls them tags) to capture the word without the tibblizing prefix. (add your own to taste!)

to match any word at least 3 characters long, you can use

<:c^3:c*>

This is one of the workarounds for the lack of proper range quantifying. It is the equivalent of  {n,} in normal RegEx

to find multi-line comments using /* */ use this

/\*(:Wh|[^:Wh])*\*/

Normally, RegEx strings will stop searching at the end of the line if you use the standard wildcard. This RegEx uses a trick to get around that.

To find a Title-cased word (word starting with a capital letter followed by lowercase)

<:Lu:Ll[a-zA-Z0-9_$]*>

Microsoft have some convenient shorthand characters to represent character classes. Here we illustrate their use with the :Lu:LI

to take out the headers that SMO puts in like
/****** Object:  StoredProcedure [dbo].[uspGetBillOfMaterials]    Script Date: 01/07/2011 19:03:05 ******/
find this,

/[\*]^6.*[\*]^6/

replace with nothing

This shows the simplest quantifier. We use the [\*]^6 to represent six stars ******

to comment out lines, select the lines, Make sure you have ‘Look in selection’ and  find

^

 replace with

--

to un-comment out lines, select the lines, Make sure you have ‘Look in selection’ and  find

 ^:b*--{.*}$

replace with

\1

To find two words separated by up to three words (in this case FROM and AS) use

<FROM(([^:a]+[:a]+)^1|([^:a]+[:a]+)^2|([^:a]+[:a]+)^3)[^:a]+AS>

With normal syntax, you’d use \b FROM (?:\W+\w+){1,3}?\W+AS\b but we have no range quantifiers, so we are forced to use the ascending alternatives (descending if we want to be greedy rather than lazy). This becomes ridiculous if we want to specify the quantifiers for a complex expression. We’d have to duplicate the long expression.

To find the first  object that is referenced by a FROM clause (doesn't successfully avoid strings or multiline comments), use

^~(:b*--.*)<FROM>{(:Wh|[^:Wh])#}<(ON|CROSS|RIGHT|INNER|OUTER|LEFT|JOIN|WHERE|ORDER|GROUP|AS)>

here you have something that is looking for a whole lot of different alternative keywords merely by grouping them and using the | character to .

To find either an integer or a  floating point number, one can use the following RegEx which is a bit long but simple in structure

~(\.)<([\+\-]@[0-9]@\.[0-9]*E[\+\-]*[0-9]*)|([\+\-]@[0-9]*\.[0-9]*)|([\+\-]@[0-9]+)

This starts at a word boundary that is not preceded by a dot. It first looks for a floating point number in exponential notation. then it looks for a number in conventional notation before finally trying for an integer.


The negative lookahead and negative lookbehind
-----------------------------------------------

The idea of look-ahead and look-behind is slightly hard to understand.
The object of the mechanism is to do be able to specify what shouldn’t or should be next to the string you are trying to match, without including the characters you look at in the match. If you are ‘replacing all’, you may want to include what you’ve looked at ahead in the next match. You could well want to look behind at things that have already been inspected in a RegEx for a match.  Using the Find/Replace RegEx syntax, we can get somewhere close to a ‘negative’ check with a ‘prevent match’; in other words we can specify what should not precede, or follow, the match, but we can’t say what should  do so, even with a double negative.  If, for example, you are searching for words in the AdventureWorks database, you’ll have the word HumanResources appearing a great deal.

~(Human)Resources  finds the word 'Resources', but not when immediately preceded by 'human' (negative lookbehind)

Human~(Resources)  finds the word Human, but not when immediately followed by 'resources' (negative lookbehind)

~(:b)Resources     finds the word Resources when not preceded by whitespace

but the expression cannot, it seems, be persuaded to find a positive lookaround.  There are plenty of times that you’d want this. An example is using RegEx strings to tidy up a block of DECLARE statements into a single list, or if you want to select  a range of characters  based on column number

-------------------------------------------------------------------------------------------------------------------------------


Taking things in stages.

For more complex tasks such as marking up code to colorize it, for creating tables from results, or for creating insert statements, it is often quicker and more maintainable to run several RegEx replacements in a particular order to achieve what you want. Let’s take a worked example.

Imagine we want to turn a result into a SELECT statement that returns a table. (it could use multi-row VALUES though there is a row limit) Our example will be short, but you’re likely to tackle much bigger results that are impossible to do by hand.

In AdventureWorks, open a query window. Set the Query -> Results to -> Text. Click on the Query -> ‘Query options…’, Click on Results Text in the tree on the left and set the dropdown box at the top right of the form to Tab Delimited. Click on the ‘include column headers in the result set’ optionbox so that it is UNTICKED.

Run this…

SELECT  ErrorLogID, ErrorTime, UserName, ErrorNumber, ErrorSeverity,
		ErrorState, ErrorProcedure, ErrorLine
FROM    ErrorLog

Click on the result pane to get focus

Find What

Replace With

Explanation
^[^\t]*$

Take out all the rows that aren’t part of the result (rows without tabs)
($)|(\t)|(^) 	','

replace all tabs, with the ',' string, as well as at the start and end of a line
'~(\.){[\+\-]@<([0-9]@\.[0-9]*E[\+\-]*[0-9]*)|([0-9]*\.[0-9]*)|([0-9]+)}' 	\1

Strip off unnecessary quotes around numbers
^', 	UNION SELECT

Put the SQL statement you want at the start of the string
,'$

Finish off the end of each line by deleting the last ,'

Then nick out the initial ‘UNION’, and you are left with…

SELECT 1,'2010-07-09 09:42:34.853','dbo',547,16,0,'uspUpdateEmployeeLogin',15
UNION SELECT 2,'2010-07-09 09:42:55.497','dbo',547,16,0,'uspUpdateEmployeeLogin',15
UNION SELECT 3,'2010-07-09 09:58:31.120','dbo',547,16,0,'uspUpdateEmployeeLogin',15
UNION SELECT 4,'2010-07-09 12:12:20.757','dbo',547,16,0,'uspUpdateEmployeeLogin',15
UNION SELECT 5,'2010-07-10 22:30:41.567','dbo',547,16,0,'uspUpdateEmployeeLogin',15

Of course, if you have strings with single-quote marks in, you’ll have to double them by replacing ‘ with ”, but otherwise, you’re done.
Feature Comparison with standard RegEx
Key
The same as standard RegEx
different symbol or syntax;
Missing from Search/Replace

Here we list out the components of the Find/Replace Regex and compare each with the equivalent in standard Regex. If the two are the same, the background is in white. If the tw are different but the functionality is pretty well the same then the background is light gray, otherwise it is silver (see the key on the left)

Standard



Not all the regular expressions are listed here. I’ve missed out the Unicode character properties and a lot of the non-standard character shortcuts. For a full list of these, you’ll need to refer to the help text provided by Microsoft in their How to: Search with Regular Expressions

https://learn.microsoft.com/en-us/sql/ssms/scripting/search-text-with-regular-expressions?redirectedfrom=MSDN&view=sql-server-ver16